/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc_tempfile.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: meferraz <meferraz@student.42porto.pt>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/19 16:15:00 by meferraz          #+#    #+#             */
/*   Updated: 2025/03/08 13:58:11 by meferraz         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/minishell.h"

static t_status	ft_generate_temp_filename(t_shell *shell, char **tempfile);

/**
 * Creates a unique temporary file for heredoc input.
 *
 * Tries to generate a unique temporary filename up to 1000 times,
 * and creates the file if it does not already exist. If all attempts
 * fail, prints an error message and returns ERROR.
 *
 * @param shell The shell context.
 * @param tempfile A pointer to a pointer to the generated filename.
 * @return SUCCESS if the file was created successfully, ERROR otherwise.
 *
 * The caller is responsible for freeing the memory allocated for the filename.
 */
t_status	ft_create_temp_file(t_shell *shell, char **tempfile)
{
	int	i;

	i = 0;
	while (i < 1000)
	{
		if (ft_generate_temp_filename(shell, tempfile) == ERROR)
			return (ERROR);
		if (access(*tempfile, F_OK) != 0)
			return (SUCCESS);
		ft_free(*tempfile);
		*tempfile = NULL;
		i++;
	}
	ft_printf(STDERR_FILENO, ERR_TEMP_FILE);
	return (ERROR);
}

/**
 * Generates a unique temporary filename for heredoc input.
 *
 * @param shell The shell context.
 * @param tempfile A pointer to a pointer to the generated filename.
 * @return SUCCESS if the filename was generated successfully, ERROR otherwise.
 *
 * The filename has the format "/tmp/minishell_heredoc_<number>",
 * where <number> is a unique number generated by incrementing the
 * shell's random number. The filename is allocated using ft_safe_calloc(),
 * and the caller is responsible for freeing it.
 */
static t_status	ft_generate_temp_filename(t_shell *shell, char **tempfile)
{
	static int	counter;
	char		*prefix;
	char		*counter_str;
	size_t		len;

	counter = shell->random_number;
	prefix = "/tmp/minishell_heredoc_";
	counter_str = ft_itoa(counter);
	if (!counter_str)
		return (ERROR);
	len = ft_strlen(prefix) + ft_strlen(counter_str) + 1;
	*tempfile = ft_safe_calloc(len);
	if (!*tempfile)
		return (ft_free(counter_str), ERROR);
	ft_strlcpy(*tempfile, prefix, len);
	ft_strlcat(*tempfile, counter_str, len);
	ft_free(counter_str);
	counter++;
	shell->random_number = counter;
	return (SUCCESS);
}

/**
 * Adds a temporary file to the shell's list of temporary files.
 *
 * This function appends the given temporary file to the shell's
 * existing list of temporary files. It dynamically allocates a new
 * array of strings to hold the updated list, copies over the existing
 * filenames, adds the new filename, and frees the old array.
 *
 * @param shell The shell structure containing the list of temporary files.
 * @param tempfile The filename of the temporary file to be added.
 */

void	ft_add_temp_file(t_shell *shell, char *tempfile)
{
	char	**new_temp_files;
	int		i;

	i = 0;
	while (shell->temp_files && shell->temp_files[i])
		i++;
	new_temp_files = ft_calloc(i + 2, sizeof(char *));
	if (!new_temp_files)
		return ;
	i = 0;
	while (shell->temp_files && shell->temp_files[i])
	{
		new_temp_files[i] = shell->temp_files[i];
		i++;
	}
	new_temp_files[i] = tempfile;
	ft_free(shell->temp_files);
	shell->temp_files = new_temp_files;
}
